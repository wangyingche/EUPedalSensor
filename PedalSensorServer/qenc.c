/**
 * Copyright (c) 2014 - 2018, Nordic Semiconductor ASA
 * 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form, except as embedded into a Nordic
 *    Semiconductor ASA integrated circuit in a product or a software update for
 *    such product, must reproduce the above copyright notice, this list of
 *    conditions and the following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 * 
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 * 
 * 4. This software, with or without modification, must only be used with a
 *    Nordic Semiconductor ASA integrated circuit.
 * 
 * 5. Any software provided in binary form under this license must not be reverse
 *    engineered, decompiled, modified and/or disassembled.
 * 
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/** @file
* @defgroup nrf_qdec_example main.c
* @{
* @ingroup nrf_qdec_example
* @brief QDEC example application main file.
*
* This is an example quadrature decoder application.
* The example requires that the QDEC A,B inputs are connected with the QENC A,B outputs and
* the QDEC LED output is connected with the QDEC LED input.
*
* The example uses the software quadrature encoder simulator QENC.
* The quadrature encoder simulator uses one channel of the GPIOTE module.
* The state of the encoder changes on the inactive edge of the sampling clock generated by the LED output.
*
* In an infinite loop, QENC produces a variable number of positive and negative pulses
* synchronously with bursts of clock impulses generated by QDEC at the LED output.
* The pulses are counted by QDEC operating in a REPORT mode.
* The pulses counted by QDEC are compared with the pulses generated by QENC.
* The test stops if there is a difference between the number of pulses counted and generated.
*
*/

#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <math.h>

#include "nrf.h"
#include "bsp.h"
#include "nrf_delay.h"
//#include "nrf_drv_qdec.h"
#include "nrf_error.h"
#include "app_error.h"
//#include "qenc_sim.h"
#include "nordic_common.h"
#include "app_timer.h"

//#define NRF_LOG_LEVEL	4
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_log_default_backends.h"
#include "qdecmain.h"
#include "posbuf.h"
#include "nrfparser.h"


APP_TIMER_DEF(m_qdec_period_read_timer_id);  /**< Polling timer id. */


/* FOR encode position simulation  */
#define SIM_ENCODER_RAW_POS_PERIOD	30 //dots	
#define PI	3.415926
uint8_t sim_encoder_raw_pos[SIM_ENCODER_RAW_POS_PERIOD];
/* FOR encode position simulation  */

uint32_t sim_encoder_index = 0;
#define DECAY_TAU			(SIM_ENCODER_RAW_POS_PERIOD)
#define DECAY_TABLE_SIZE 	(DECAY_TAU*3+20)
float decaytable[DECAY_TABLE_SIZE];
int start_sim;
static int8_t rssi_value;

#define SIM_IDLE 0
#define SIM_TRANS_UP 1
#define SIM_SETTLE 2
#define SIM_TRANS_DOWN 3
#define SIM_STOP 4
#define GREAT_THAN_SS(A,B)		(A > ##A##_ss+(B))
const uint8_t aconst_state_string[5][20] = 
{
	"SIM_IDLE",
	"SIM_TRANS_UP",
	"SIM_SETTLE",
	"SIM_TRANS_DOWN",
	"SIM_STOP"
};

static void qdec_period_read_timer_handler(void* p_context)
{
	static int tick;
	//static int tick_ss;
	static uint32_t ss;
	static uint32_t ss_ss;
	static uint32_t factor_index;
	float raw_pos;
	float factor;
	
	//NRF_LOG ("qdec_read\n");
	if (sim_encoder_index >=SIM_ENCODER_RAW_POS_PERIOD) sim_encoder_index = 0;
	raw_pos = sim_encoder_raw_pos[sim_encoder_index++];
	switch (ss) {
	case SIM_IDLE:
		factor_index = 0;
		sim_encoder_index = 0;
		ss = SIM_TRANS_UP;
		break;
	case SIM_TRANS_UP:
		factor = decaytable[factor_index++];
		raw_pos = raw_pos*factor;
		if ( factor > (float)0.98 )
			ss = SIM_SETTLE;
		break;
	case SIM_SETTLE:
		factor = 1.0;
		raw_pos *= factor;
		if ( start_sim == 0 ) {
			factor_index = DECAY_TABLE_SIZE-1;
			ss = SIM_TRANS_DOWN;
		}			
		break;
	case SIM_TRANS_DOWN:
		factor = decaytable[factor_index--];
		raw_pos = raw_pos*factor;
		if ( factor <= (float)0.1 ) 
			ss = SIM_STOP;
		break;
	case SIM_STOP:
		{
			uint32_t err_code;
			err_code = app_timer_stop (m_qdec_period_read_timer_id);
			if ( err_code != NRF_SUCCESS )
				NRF_LOG_INFO ("qdec_period_read_ctrl stop fail: %d\n", err_code);
			ss = SIM_IDLE;
		}
		break;
	default: 
		break;
	}
	if (ss_ss != ss) {
		NRF_LOG_INFO ("ss=%s factor=%f factor_index=%d\n", &aconst_state_string[ss][0], factor, factor_index);
		
		//tick_ss = tick;
		ss_ss = ss;
	}
	
	qdec_info info;
	info.raw_pos = raw_pos;
	info.win_pos = posbuf_add(info.raw_pos);
	info.rssi = rssi_value;
	qdec_set (&info);
	
	if (IsEnableNotify()) {
		//int sts =
		NRFNotifyPosInfo ((uint8_t *)&info, sizeof(info) /*4*/);
		//NRF_LOG_INFO("sts=%x rawp=%d wpos=%d rssi=%d\n",sts, qdec.raw_pos, qdec.win_pos, qdec.rssi);
	}
	
	tick++;
}

void qdec_period_read_ctrl (int start_or_stop, uint32_t minisec)
{
	uint32_t err_code = NRF_SUCCESS;
	NRF_LOG_INFO ("qdec_period_read_ctrl start_or_stop=%d minisec=%d\n", start_or_stop, minisec);
	if (start_or_stop == 1) {
		start_sim = 1;
		err_code = app_timer_start (m_qdec_period_read_timer_id, APP_TIMER_TICKS(minisec), NULL);
		if ( err_code != NRF_SUCCESS )
		NRF_LOG_INFO ("qdec_period_read_ctrl start fail: %d\n", err_code);
	} else {
		start_sim = 0;
		//err_code = app_timer_stop (m_qdec_period_read_timer_id);
		//if ( err_code != NRF_SUCCESS )
		//NRF_LOG_PRINTF ("qdec_period_read_ctrl stop fail: %d\n", err_code);
	}
}

void qdec_period_read_timer_init(void)
{
	static int initialized;
	int i;
    uint32_t err_code = NRF_SUCCESS;
	if (initialized) return;
	//m_qdec_period_read_timer_id
	err_code = app_timer_create(&m_qdec_period_read_timer_id,
								APP_TIMER_MODE_REPEATED,
								qdec_period_read_timer_handler);
	if ( err_code != NRF_SUCCESS )
		NRF_LOG_INFO ("qdec_period_read_timer_init failed 1: %d\n", err_code);

	for (i=0;i<SIM_ENCODER_RAW_POS_PERIOD;i++) {
		sim_encoder_raw_pos[i] = 40+10*sin(2*PI/SIM_ENCODER_RAW_POS_PERIOD*i);
	}		
	for (i=0;i<DECAY_TABLE_SIZE;i++) {
		if ( i < 10 )
			decaytable[i] = 0;
		else if ( i > DECAY_TABLE_SIZE-10)
			decaytable[i] = 1;
		else
			decaytable[i] = 1-exp(-(float)i/DECAY_TAU);
		//NRF_LOG_INFO ("decaytable[%d] = %f\n", i, decaytable[i]);
		//nrf_delay_ms (10);
	}		
	initialized = 1;
}


/** @} */

