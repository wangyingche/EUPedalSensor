/**
 * Copyright (c) 2014 - 2018, Nordic Semiconductor ASA
 * 
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form, except as embedded into a Nordic
 *    Semiconductor ASA integrated circuit in a product or a software update for
 *    such product, must reproduce the above copyright notice, this list of
 *    conditions and the following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 * 
 * 3. Neither the name of Nordic Semiconductor ASA nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 * 
 * 4. This software, with or without modification, must only be used with a
 *    Nordic Semiconductor ASA integrated circuit.
 * 
 * 5. Any software provided in binary form under this license must not be reverse
 *    engineered, decompiled, modified and/or disassembled.
 * 
 * THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 */
/** @file
* @defgroup nrf_qdec_example main.c
* @{
* @ingroup nrf_qdec_example
* @brief QDEC example application main file.
*
* This is an example quadrature decoder application.
* The example requires that the QDEC A,B inputs are connected with the QENC A,B outputs and
* the QDEC LED output is connected with the QDEC LED input.
*
* The example uses the software quadrature encoder simulator QENC.
* The quadrature encoder simulator uses one channel of the GPIOTE module.
* The state of the encoder changes on the inactive edge of the sampling clock generated by the LED output.
*
* In an infinite loop, QENC produces a variable number of positive and negative pulses
* synchronously with bursts of clock impulses generated by QDEC at the LED output.
* The pulses are counted by QDEC operating in a REPORT mode.
* The pulses counted by QDEC are compared with the pulses generated by QENC.
* The test stops if there is a difference between the number of pulses counted and generated.
*
*/

#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>

#include "nrf.h"
#include "bsp.h"
#include "nrf_delay.h"
#include "nrf_drv_qdec.h"
#include "nrf_error.h"
#include "app_error.h"
//#include "qenc_sim.h"
#include "nordic_common.h"

//#define NRF_LOG_LEVEL	4
#include "nrf_log.h"
#include "nrf_log_ctrl.h"
#include "nrf_log_default_backends.h"
#include "qdecmain.h"
#include "posbuf.h"
#include "nrfparser.h"
#include "sadcmain.h"


static volatile bool m_report_ready_flag = false;
static volatile bool m_first_report_flag = true;
static volatile uint32_t m_accdblread;
static volatile int32_t m_accread;
static qdec_info qdec;
static int32_t m_pos;
static int8_t rssi_value;
static uint8_t pedaling_count;

extern int g_enable_notify;


#define QDEC_ALWAYS_ENABLE	1


#if (QDEC_CONFIG_LEDPRE >= 128)
    #warning "This example assumes that the QDEC LED changes state. Make sure that 'Sample Period' in QDEC config is less than 'LED pre-time'."
#endif

extern void idle_state_handle(void);


void qdec_set (qdec_info *info)
{
	qdec.raw_pos = info->raw_pos;
	qdec.win_pos = info->win_pos;
	qdec.rssi = info->rssi;
}

int qdec_get_raw_pos (void)
{
	return qdec.raw_pos;
}

int qdec_get_win_pos (void)
{
	return qdec.win_pos;
}

int KeepOnPedaling (void)
{
	return (pedaling_count > 10);
}

static int qdec_event;
static uint32_t qdec_report_count;
int get_qdec_event (void)
{
	return qdec_event;
}

void qdec_event_clear (void)
{
	qdec_event = 0;
}

uint32_t get_qdec_report_count (void)
{
	return qdec_report_count;
}
void set_qdec_report_count (uint32_t value)
{
	qdec_report_count = value;
}

static void qdec_event_handler(nrf_drv_qdec_event_t event)
{
	//uint32_t err_code;
	//uint8_t buf[100];
    if (event.type == NRF_QDEC_EVENT_REPORTRDY) /* wyn: once per 20 ms(if pos is changed.) */
    {
			int16_t win_pos;
			m_accdblread = event.data.report.accdbl;
			m_accread = event.data.report.acc;
			m_pos += m_accread;
			m_report_ready_flag = true;
			win_pos = posbuf_add (m_accread);
			//nrf_drv_qdec_disable();

			/* send position to client. */
			//sprintf ((char *)buf, "m_pos=%d m_accread=%d m_accdblread=%d\n", m_pos, m_accread, m_accdblread);
			//err_code = ble_nus_string_send(&m_nus, buf, 20);
			qdec.raw_pos = m_accread;
			qdec.win_pos = win_pos;
			//qdec.accdblread = m_accdblread;
			qdec.rssi = rssi_value;
			//qdec.battery_level = get_battery_level ();
			if (win_pos > 10)
				pedaling_count++;
			else
				pedaling_count = 0;
#if 1
			if (IsEnableNotify()) {
				int sts = NRFNotifyPosInfo ((uint8_t *)&qdec, sizeof(qdec_info) /*4*/);
				if (sts != NRF_SUCCESS)
					NRF_LOG_INFO("FAIL on NRFNotifyPosInfo, sts=%x", sts);
					//NRF_LOG_INFO("sts=%x rawp=%d wpos=%d rssi=%d",sts, qdec.raw_pos, qdec.win_pos, qdec.rssi);
			}

#else
			err_code = ble_nus_string_send(&m_nus, (uint8_t *)&qdec, 4 /*sizeof(qdec)*/); /*send to wheel*/
			if (err_code != NRF_SUCCESS)
			{
				//APP_ERROR_CHECK(err_code);
				NRF_LOG_INFO ("err_code=%d\n", err_code);
			}	
#endif		
			qdec_event++;
			qdec_report_count++;
    }
	/* enable samplerdy int by QDEC_CONFIG_SAMPLE_INTEN = true */
    //if (event.type == NRF_QDEC_EVENT_SAMPLERDY) {
	//		NRF_LOG (".");
	//}
}

void qdec_main(void)
{
    uint32_t err_code;
	//uint32_t max_number_of_pulses;
    //err_code = NRF_LOG_INIT(NULL);
    //APP_ERROR_CHECK(err_code);
	//
    //NRF_LOG_DEFAULT_BACKENDS_INIT();

	posbuf_init ();
	
    // Initialize hardware
    err_code = nrf_drv_qdec_init(NULL, qdec_event_handler);
    APP_ERROR_CHECK(err_code);

    nrf_qdec_reportper_to_value(QDEC_CONFIG_REPORTPER);

    // Initialize quadrature encoder simulator
    //qenc_init((nrf_qdec_ledpol_t)nrf_qdec_ledpol_get());

    NRF_LOG_INFO("QDEC testing started.");

	nrf_drv_qdec_enable();                  // start burst sampling clock, clock will be stopped by REPORTRDY event
    while (0)
    {
      // change a number and sign of pulses produced by simulator in a loop
        while (! m_report_ready_flag)           // wait for a report
        {
          //__WFE();
			nrf_delay_ms (500);
			NRF_LOG_RAW_INFO("*");
			//printf ("*");
			idle_state_handle();
        }
#if QDEC_ALWAYS_ENABLE==0
        nrf_drv_qdec_enable();                  // start burst sampling clock, clock will be stopped by REPORTRDY event
#endif		
        //NRF_LOG_RAW_INFO("!");
		printf ("!");
        m_report_ready_flag = false;
		NRF_LOG_FLUSH();
    }
}

/** @} */
